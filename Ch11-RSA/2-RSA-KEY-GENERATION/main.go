/*
RSA Key Generation
Something you never want to do in the real world is to write your own cryptography code from scratch. Always use well-tested crypto libraries in production.

That said, we've been asked at Passly to write our own RSA from scratch to compare against the Go standard library's implementation. Don't worry, it's just for benchmarking purposes.

Generating big numbers
First of all, we need to generate some really big numbers. Go has a library for that: math/big. It's a bit tricky to use, but we'll figure it out together.

2 very large prime numbers are generated, we'll call them p and q
The first part of the public key is generated by multiplying p and q together, we'll call this n
Assignment
Complete the generatePrivateNums and getN functions.

generatePrivateNums(keysize int) (*big.Int, *big.Int)
Use the provided getBigPrime function to generate two prime numbers of the given keysize in bits. Be sure to generate p first, as we're relying on the determinism of the random number generator. (Normally we would use the crypto/rand package's rand.Prime if we wanted true randomness).

getN(p, q *big.Int) *big.Int
Use the math/big package's .Mul method to multiply p and q together to get n.

Notes
Big Integers
Notice that we're using *big.Int instead of int or int64. That's because we need to be able to handle numbers that are too big to fit in a regular integer. Most of the arithmetic with big integers is done through methods on the *big.Int type, and they mutate the pointer receiver.

Those numbers are HUGE
You might notice that it takes a minute or so to generate those numbers, and that's because they're really big. Think about a 600-digit number! That's a 1 with 600 0s after it.
*/

package main

import (
	"errors"
	"fmt"
	"io"
	"math/big"
	mrand "math/rand"
)

// Generate two large prime numbers
func generatePrivateNums(keysize int) (*big.Int, *big.Int) {
	p, err := getBigPrime(keysize)
	if err != nil {
		return nil, nil
	}
	q, err := getBigPrime(keysize)
	if err != nil {
		return nil, nil
	}
	return p, q
}

// Calculate n = p * q
func getN(p, q *big.Int) *big.Int {
	n := new(big.Int)
	return n.Mul(p, q)
}

// don't touch below this line

func firstNDigits(n big.Int, numDigits int) string {
	if len(n.String()) < numDigits {
		return fmt.Sprintf("%v", n.String())
	}
	return fmt.Sprintf("%v...", n.String()[:numDigits])
}

func test(keySize int) {
	p, q := generatePrivateNums(keySize)
	fmt.Printf("Generated p: %v it has %v digits\n", firstNDigits(*p, 10), len(p.String()))
	fmt.Printf("Generated q: %v it has %v digits\n", firstNDigits(*q, 10), len(q.String()))

	n := getN(p, q)
	fmt.Printf("Generated n: %v it has %v digits\n", firstNDigits(*n, 10), len(n.String()))

	fmt.Println("========")
}

var randReader = mrand.New(mrand.NewSource(0))

func getBigPrime(bits int) (*big.Int, error) {
	if bits < 2 {
		return nil, errors.New("prime size must be at least 2-bit")
	}
	b := uint(bits % 8)
	if b == 0 {
		b = 8
	}
	bytes := make([]byte, (bits+7)/8)
	p := new(big.Int)
	for {
		if _, err := io.ReadFull(randReader, bytes); err != nil {
			return nil, err
		}
		bytes[0] &= uint8(int(1<<b) - 1)
		if b >= 2 {
			bytes[0] |= 3 << (b - 2)
		} else {
			bytes[0] |= 1
			if len(bytes) > 1 {
				bytes[1] |= 0x80
			}
		}
		bytes[len(bytes)-1] |= 1
		p.SetBytes(bytes)
		if p.ProbablyPrime(20) {
			return p, nil
		}
	}
}

func main() {
	test(512)
	test(1024)
	test(2048)
}
